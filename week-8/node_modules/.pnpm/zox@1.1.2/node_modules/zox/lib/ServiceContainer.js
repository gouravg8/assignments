"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const serviceKey = Symbol('Service Container');
exports.dependenciesKey = Symbol('Dependency');
function hasOnResolved(obj) {
    return obj && typeof obj === 'object' && typeof obj['onResolved'] === 'function';
}
exports.hasOnResolved = hasOnResolved;
class IServiceContainer {
    get serviceKey() {
        return serviceKey;
    }
}
exports.IServiceContainer = IServiceContainer;
class ServiceContainer extends IServiceContainer {
    constructor() {
        super();
        this.services = {};
        this.unresolvedServices = {};
        this.register(this);
    }
    register(service) {
        if (this.services.hasOwnProperty(service.serviceKey)) {
            console.warn(`Overriding service "${service.serviceKey.toString().slice(7, -1)}"`);
        }
        this.services[service.serviceKey] = service;
    }
    registerAs(key, service) {
        const k = typeof key === 'symbol' ? key : key.prototype.serviceKey;
        if (this.services.hasOwnProperty(k)) {
            console.warn(`Overriding service "${k.toString().slice(7, -1)}"`);
        }
        this.services[k] = service;
    }
    registerUnresolved(service) {
        if (this.services.hasOwnProperty(service.serviceKey)) {
            console.warn(`Service "${service.serviceKey.toString().slice(7, -1)}" is already registered`);
        }
        else {
            if (this.unresolvedServices.hasOwnProperty(service.serviceKey)) {
                console.warn(`Overriding service "${service.serviceKey.toString().slice(7, -1)}"`);
            }
            this.unresolvedServices[service.serviceKey] = service;
        }
    }
    registerUnresolvedAs(key, service) {
        const k = typeof key === 'symbol' ? key : key.prototype.serviceKey;
        if (this.services.hasOwnProperty(k)) {
            console.warn(`Service "${k.toString().slice(7, -1)}" is already registered`);
        }
        else {
            if (this.unresolvedServices.hasOwnProperty(k)) {
                console.warn(`Overriding service "${k.toString().slice(7, -1)}"`);
            }
            this.unresolvedServices[k] = service;
        }
    }
    get(key, optional) {
        const k = typeof key === 'symbol' ? key : key.prototype.serviceKey;
        if (this.services.hasOwnProperty(k)) {
            return this.services[k];
        }
        else if (this.unresolvedServices.hasOwnProperty(k)) {
            this.resolve(this.unresolvedServices[k], true);
            this.services[k] = this.unresolvedServices[k];
            delete this.unresolvedServices[k];
            return this.services[k];
        }
        if (optional) {
            return;
        }
        throw new Error(`Service "${k.toString().slice(7, -1)}" is not registered`);
    }
    resolve(target, triggerOnResolved = false) {
        if (exports.dependenciesKey in target) {
            let dependencyInfo = target[exports.dependenciesKey];
            do {
                const properties = Object.getOwnPropertyNames(dependencyInfo.dependencies);
                for (const key of properties) {
                    target[key] = this.get(dependencyInfo.dependencies[key]);
                }
                const symbols = Object.getOwnPropertySymbols(dependencyInfo.dependencies);
                for (const key of symbols) {
                    target[key] = this.get(dependencyInfo.dependencies[key]);
                }
                dependencyInfo = dependencyInfo.subDependencies;
            } while (dependencyInfo);
        }
        if (triggerOnResolved && hasOnResolved(target)) {
            target.onResolved();
        }
    }
    create(targetClass, ...args) {
        const instance = new targetClass(...args);
        this.resolve(instance);
        if (hasOnResolved(instance)) {
            instance.onResolved();
        }
        return instance;
    }
}
exports.ServiceContainer = ServiceContainer;
function Dependency(depOrTarget, property) {
    if (typeof property === 'string' || typeof property === 'symbol') {
        const dependency = Reflect.getMetadata("design:type", depOrTarget, property);
        addDependency(dependency, depOrTarget, property);
    }
    else {
        return function (target, property) {
            addDependency(depOrTarget, target, property);
        };
    }
}
exports.Dependency = Dependency;
function addDependency(dependency, target, property) {
    if (!target.hasOwnProperty(exports.dependenciesKey)) {
        target[exports.dependenciesKey] = {
            subDependencies: exports.dependenciesKey in target ? target[exports.dependenciesKey] : undefined,
            dependencies: {}
        };
    }
    target[exports.dependenciesKey].dependencies[property] =
        typeof dependency === 'symbol' ? dependency : dependency.prototype.serviceKey;
}
//# sourceMappingURL=ServiceContainer.js.map