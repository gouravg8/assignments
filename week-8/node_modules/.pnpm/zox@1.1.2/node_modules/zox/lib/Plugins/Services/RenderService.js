"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ServiceContainer_1 = require("../../ServiceContainer");
const ServicePluginManager_1 = require("../../PluginManagers/ServicePluginManager");
const Utility_1 = require("../../Utility");
const path = require("path");
const fs = require("fs");
const ConfigService_1 = require("../../Services/ConfigService");
const RenderEnginePluginManager_1 = require("../PluginManagers/RenderEnginePluginManager");
const FileWatch_1 = require("../../Misc/FileWatch");
const serviceKey = Symbol('Render');
class IRenderService {
    get serviceKey() {
        return serviceKey;
    }
}
exports.IRenderService = IRenderService;
let RenderService = class RenderService extends IRenderService {
    constructor() {
        super(...arguments);
        this.compileCache = {};
    }
    onResolved() {
        const globalConfig = this.config.getGlobalConfig();
        const config = this.config.getConfig('render');
        this.directory = typeof config.directory === 'string' ? config.directory : 'templates';
        this.debug = globalConfig.debug;
        if (globalConfig.watch) {
            FileWatch_1.watch(this.directory, (e) => {
                switch (e.event) {
                    case 'added':
                        this.templateListCache = undefined;
                        break;
                    case 'changed':
                        this.compileCache[e.info.filePath] = undefined;
                        break;
                    case 'removed':
                        this.templateListCache = undefined;
                        this.compileCache[e.info.filePath] = undefined;
                        break;
                }
            }, 500);
        }
        this.renderEngineInfoList = this.renderEnginePluginManager.renderEngineInfoList;
    }
    render(templateCandidates, data) {
        const resolvedTemplate = this.resolveTemplate(templateCandidates);
        let result;
        let candidatesDebug;
        if (this.debug) {
            candidatesDebug = templateCandidates.map(candidate => `\n * ${candidate}`).join('');
            candidatesDebug = '<!-- Candidates: ' + candidatesDebug + ' -->';
        }
        if (resolvedTemplate) {
            let template;
            if (this.compileCache[resolvedTemplate.templateFile]) {
                template = this.compileCache[resolvedTemplate.templateFile];
            }
            else {
                try {
                    const templateString = fs.readFileSync(resolvedTemplate.templateFile, 'utf8');
                    template = resolvedTemplate.renderEngine.compile(templateString, resolvedTemplate.templateFile);
                    this.compileCache[resolvedTemplate.templateFile] = template;
                }
                catch (e) {
                    console.error('Failed to load template:', resolvedTemplate.templateFile, '\n', e.toString());
                    return '';
                }
            }
            result = template(data);
            if (this.debug) {
                const sourceDebug = `\n<!-- OUTPUT FROM: ${resolvedTemplate.templateFile} -->\n`;
                result = candidatesDebug + sourceDebug + result + `\n<!-- END FROM: ${resolvedTemplate.templateFile} -->`;
            }
        }
        else {
            if (this.debug) {
                result = candidatesDebug + '\n<!-- NO TEMPLATE FOUND -->';
            }
            else {
                result = '';
            }
        }
        return result;
    }
    resolveTemplate(candidates) {
        if (!this.templateListCache) {
            this.templateListCache = Utility_1.listFilesSync(this.directory);
        }
        for (let c = candidates.length - 1; c >= 0; --c) {
            const candidate = candidates[c];
            for (const template of this.templateListCache) {
                const basename = path.basename(template);
                if (basename.startsWith(candidate)) {
                    const templateExt = basename.slice(candidate.length + 1);
                    for (const renderEngineInfo of this.renderEngineInfoList) {
                        if (renderEngineInfo.extensions.indexOf(templateExt) >= 0) {
                            return {
                                templateFile: template,
                                renderEngine: renderEngineInfo.renderEngine,
                            };
                        }
                    }
                }
            }
        }
        return false;
    }
};
__decorate([
    ServiceContainer_1.Dependency,
    __metadata("design:type", ConfigService_1.IConfigService)
], RenderService.prototype, "config", void 0);
__decorate([
    ServiceContainer_1.Dependency,
    __metadata("design:type", RenderEnginePluginManager_1.IRenderEnginePluginManager)
], RenderService.prototype, "renderEnginePluginManager", void 0);
RenderService = __decorate([
    ServicePluginManager_1.Service
], RenderService);
exports.RenderService = RenderService;
//# sourceMappingURL=RenderService.js.map