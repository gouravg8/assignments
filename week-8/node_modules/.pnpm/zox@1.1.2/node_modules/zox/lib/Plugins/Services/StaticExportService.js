"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ServiceContainer_1 = require("../../ServiceContainer");
const ServicePluginManager_1 = require("../../PluginManagers/ServicePluginManager");
const ControllerResolverPluginManager_1 = require("../PluginManagers/ControllerResolverPluginManager");
const LayoutService_1 = require("./LayoutService");
const fs = require("fs");
const path = require("path");
const util = require("util");
const mkdirAsync = util.promisify(fs.mkdir);
const statAsync = util.promisify(fs.stat);
const writeFileAsync = util.promisify(fs.writeFile);
const serviceKey = Symbol('Static Export');
class IStaticExportService {
    get serviceKey() {
        return serviceKey;
    }
}
exports.IStaticExportService = IStaticExportService;
let StaticExportService = class StaticExportService extends IStaticExportService {
    async getPages(url, items) {
        items = items || [];
        const content = await this.getContent(url);
        items.push(content);
        if (content.error) {
            console.error(content.error);
        }
        else if (!content.isSupported) {
            console.warn('Response not supported:', content.response);
        }
        else {
            if (content.isPage) {
                const urls = getUrlsOnPage(content.content);
                for (const u of urls) {
                    if (u.startsWith('/') && !u.startsWith('//') && items.every(item => item.url !== u)) {
                        await this.getPages(u, items);
                    }
                }
            }
        }
        return items;
    }
    async getContent(url) {
        const controller = this.controllerResolverPluginManager.tryResolveController('GET', url);
        if (controller) {
            try {
                const msg = { url, method: 'GET', headers: {} };
                const result = await (ControllerResolverPluginManager_1.isControllerInstance(controller) ? controller.handle(msg) : controller(msg));
                return this.getResponseContent(result, url);
            }
            catch (e) {
                return { url, error: `Failed to get content on page '${url}', Error: ${e}` };
            }
        }
        else {
            return { url, error: `Url '${url}' Not Found` };
        }
    }
    getResponseContent(response, url) {
        const pageContent = {
            url,
            response,
            isSupported: true,
            isPage: false,
        };
        if (response.statusCode !== 200) {
            pageContent.error = `Got status code ${response.statusCode} for url '${url}'`;
        }
        else if (isRenderResponse(response)) {
            pageContent.content = this.layoutService.wrap(response.renderable).toString();
            pageContent.isPage = true;
        }
        else if (isJsonResponse(response)) {
            pageContent.content = response.json;
        }
        else if (isStringResponse(response)) {
            pageContent.content = response.responseString;
        }
        else if (isFileResponse(response)) {
            pageContent.content = typeof response.file === 'string' ?
                fs.readFileSync(response.file) :
                fs.readFileSync(response.file.filePath);
        }
        else {
            pageContent.isSupported = false;
        }
        return pageContent;
    }
    async savePages(directory, pages) {
        await makeDirRecursive(directory);
        for (const page of pages) {
            if (!page.error && page.isSupported) {
                let dest = page.isPage ? path.join(page.url, '/index.html') : page.url;
                dest = path.join(directory, dest);
                await makeDirRecursive(path.dirname(dest));
                await writeFileAsync(dest, page.content);
            }
        }
    }
};
__decorate([
    ServiceContainer_1.Dependency,
    __metadata("design:type", ControllerResolverPluginManager_1.IControllerResolverPluginManager)
], StaticExportService.prototype, "controllerResolverPluginManager", void 0);
__decorate([
    ServiceContainer_1.Dependency,
    __metadata("design:type", LayoutService_1.ILayoutService)
], StaticExportService.prototype, "layoutService", void 0);
StaticExportService = __decorate([
    ServicePluginManager_1.Service
], StaticExportService);
exports.StaticExportService = StaticExportService;
function isRenderResponse(response) {
    return response.hasOwnProperty('renderable');
}
function isJsonResponse(response) {
    return response.hasOwnProperty('json');
}
function isStringResponse(response) {
    return response.hasOwnProperty('responseString');
}
function isFileResponse(response) {
    return response.hasOwnProperty('file');
}
function getUrlsOnPage(page) {
    const urls = [];
    let start;
    let end = 0;
    while ((start = page.indexOf('href="', end + 1)) > 0) {
        end = page.indexOf('"', start + 6);
        if (end < 0) {
            break;
        }
        urls.push(page.substring(start + 6, end));
    }
    end = 0;
    while ((start = page.indexOf('src="', end + 1)) > 0) {
        end = page.indexOf('"', start + 5);
        if (end < 0) {
            break;
        }
        urls.push(page.substring(start + 5, end));
    }
    return urls;
}
exports.getUrlsOnPage = getUrlsOnPage;
async function makeDirRecursive(directory) {
    try {
        await mkdirAsync(directory);
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            await makeDirRecursive(path.dirname(directory));
            await mkdirAsync(directory);
        }
        else {
            const stat = await statAsync(directory);
            if (!stat.isDirectory()) {
                throw new Error(`File '${directory}' already exists, but is not a directory.`);
            }
        }
    }
}
exports.makeDirRecursive = makeDirRecursive;
//# sourceMappingURL=StaticExportService.js.map