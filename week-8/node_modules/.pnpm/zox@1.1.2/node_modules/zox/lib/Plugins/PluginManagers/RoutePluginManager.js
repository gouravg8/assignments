"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const zox_plugins_1 = require("zox-plugins");
const ControllerResolverPluginManager_1 = require("./ControllerResolverPluginManager");
const RoutingUtility_1 = require("../../RoutingUtility");
const PluginDiscoveryService_1 = require("../../Services/PluginDiscoveryService");
const ServiceContainer_1 = require("../../ServiceContainer");
const pluginKey = Symbol('route');
let RoutePluginManager = class RoutePluginManager {
    constructor() {
        this.controllersByTokens = [];
        this.controllersByRegExp = [];
    }
    onResolved() {
        const pluginDefinitions = this.pluginDiscovery.getPlugins(pluginKey);
        for (const pluginDefinition of pluginDefinitions) {
            if (typeof pluginDefinition.data.route === 'string') {
                this.controllersByTokens.push({
                    controllerClass: pluginDefinition.pluginClass,
                    method: pluginDefinition.data.method,
                    tokens: RoutingUtility_1.routeTokens(pluginDefinition.data.route),
                });
            }
            else {
                this.controllersByRegExp.push({
                    controllerClass: pluginDefinition.pluginClass,
                    method: pluginDefinition.data.method,
                    regexp: pluginDefinition.data.route,
                });
            }
        }
    }
    tryResolveController(method, parsedUrl, tokens) {
        for (const controllerData of this.controllersByTokens) {
            if (controllerData.method === method || controllerData.method === 'ANY') {
                const match = RoutingUtility_1.tryMatchRoute(tokens, controllerData.tokens);
                if (match !== false) {
                    if (ControllerResolverPluginManager_1.isControllerClass(controllerData.controllerClass)) {
                        const controller = this.container.create(controllerData.controllerClass);
                        controller.query = parsedUrl.query;
                        if (match !== true) {
                            controller.params = match;
                        }
                        return controller;
                    }
                    else if (controllerData.controllerClass.prototype) {
                        return controllerData.controllerClass.bind({
                            container: this.container,
                            query: parsedUrl.query,
                            params: match !== true ? match : undefined,
                        });
                    }
                    else {
                        return controllerData.controllerClass;
                    }
                }
            }
        }
        for (const controllerData of this.controllersByRegExp) {
            if (controllerData.method === method || controllerData.method === 'ANY') {
                if (controllerData.regexp.test(parsedUrl.pathname)) {
                    if (ControllerResolverPluginManager_1.isControllerClass(controllerData.controllerClass)) {
                        const controller = this.container.create(controllerData.controllerClass);
                        controller.query = parsedUrl.query;
                        return controller;
                    }
                    else if (controllerData.controllerClass.prototype) {
                        return controllerData.controllerClass.bind({
                            container: this.container,
                            query: parsedUrl.query,
                        });
                    }
                    else {
                        return controllerData.controllerClass;
                    }
                }
            }
        }
    }
};
__decorate([
    ServiceContainer_1.Dependency,
    __metadata("design:type", ServiceContainer_1.IServiceContainer)
], RoutePluginManager.prototype, "container", void 0);
__decorate([
    ServiceContainer_1.Dependency,
    __metadata("design:type", PluginDiscoveryService_1.IPluginDiscoveryService)
], RoutePluginManager.prototype, "pluginDiscovery", void 0);
RoutePluginManager = __decorate([
    ControllerResolverPluginManager_1.ControllerResolver(0)
], RoutePluginManager);
exports.RoutePluginManager = RoutePluginManager;
function Route(options) {
    if (!options.method) {
        options.method = 'GET';
    }
    if (options.method === '*') {
        options.method = 'ANY';
    }
    const upperCaseMethod = options.method.toUpperCase();
    if (['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS', 'ANY'].indexOf(upperCaseMethod) < 0) {
        console.trace('Potentially invalid http method: ' + options.method);
    }
    options.method = upperCaseMethod;
    return zox_plugins_1.PluginSetup(pluginKey, options);
}
exports.Route = Route;
function Get(route) { return Route({ method: 'GET', route }); }
exports.Get = Get;
function Post(route) { return Route({ method: 'POST', route }); }
exports.Post = Post;
function Put(route) { return Route({ method: 'PUT', route }); }
exports.Put = Put;
function Patch(route) { return Route({ method: 'PATCH', route }); }
exports.Patch = Patch;
function Delete(route) { return Route({ method: 'DELETE', route }); }
exports.Delete = Delete;
function Head(route) { return Route({ method: 'HEAD', route }); }
exports.Head = Head;
function Options(route) { return Route({ method: 'OPTIONS', route }); }
exports.Options = Options;
function AnyMethod(route) { return Route({ method: 'ANY', route }); }
exports.AnyMethod = AnyMethod;
//# sourceMappingURL=RoutePluginManager.js.map